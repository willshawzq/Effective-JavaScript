## 理解JavaScript的浮点数

### 重点
+ **JavaScript的数字都是双精度的浮点数**
+ **JavaScript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型**
+ **位运算符将数字视为32为的有符号整数**
+ **当心浮点运算中的精度问题**

在JavaScript中所有的数字都是双精度浮点数，表示的数值范围从`Math.pow(-2, 53)`到`Math.pow(2, 53)`(不知道次方如何打出来~~)。
因此无论对哪种数据取`typeof`的值都是`number`：
```
typeof 12;   //number
typeof 12.3; //number
typeof -3.4; //number
```

很明显`JavaScript`中所有的整数都是有效的双精度浮点数，尽管缺少明显的整数类型，但完全可以进行整数运算。
但是在表示小数的时候，一些看是最简单的算术运算和数学定律都可能参数不正确的结果：

```
0.1 + 0.2; //0.30000000000000004
0.1 + 0.2 === 0.3； //false
```
上面的结果是不是让人非常吃惊？！尽管64位的精度已经相当高了，但是双精度浮点数也只能表示一组有限的数字，而不能表示所有的实数集。浮点预算只能产生近似的结果，四舍五入到最接近的可表示实数。
所以随着舍入误差的积累，就可能出现上述让人意想不到的情况。
```
(0.1 + 0.2) + 0.3; //0.6000000000000001
0.1 + (0.2 + 0.3); //0.6
```
这数学里面最基本的结合律，居然都不成立，这会让小朋友怀疑人生的！！
所以当遇到对精度要求很高的场景时，比如和钱相关的时候，我们都尽可能先转成整数来实现，然后再回退到原来的单位。

虽然在`JavaScript`中不推荐使用位运算，但是在JS中位运算是怎么处理的呢？
`JavaScript`不会对浮点数作为操作数进行运算，而是会隐式地转换成32为整数，然后进行处理。
比如：`8 | 1；// 9`
这个算式中的8和1都是双精度浮点数，他们也可以表示成32位0、1的序列。
```
8: 00000000000000000000000000001000
1: 00000000000000000000000000000001
9: 00000000000000000000000000001001
```
1、8和9的32位二进制序列如上，因为或运算中两位比特中任意一位为1，该位的运算结果就为1.故而得到了`(8 | 1) === 9`这个结果。
我们也可以通过`(8).toString(2)`的办法来获得二进制的表示。PS：toSting方法的参数指定了其转换基数，这里基数为2，结果省略了左边多余的0，因为他们并不影响最终结果。

**这里有个小点就是数字直接调用`toString`方法的时候，需要把数字自变量用括号括起来，或者`8..toString(2)`。因为数字可能是小数，所以解析的时候会把`.`当作数字的小数点去解析，那后面的方法便成了非法字符了。**

我们通过或运算得到的结果通过`parseInt('1001', 2)`可以转换成十进制的表示方法，只需在`parseInt`方法的第二个参数传入解析的基数即可（默认为10）。

自此我们可以发现，`JavaScript`进行位运算的时候，他们会将操作数先转为整数，然后用整数位模式进行运算，最后将结果转换为标准的`JavaScript`浮点数。一般情况下`JavaScript`引擎需要做一些额外的工作来进行这些转换。
